"""
src/solution.py
В этом упражнении вам предстоит попрактиковаться в использовании встроенных функций map(), filter(), reduce()
(эту нужно импортировать из functools). На их основе вам нужно реализовать три функции: keep_truthful(), abs_sum() и walk().

Функция keep_truthful() должна принимать на вход итерируемый источник значений и возвращать итератор, отдающий только
те значения из источника, которые "истинны" (вам пригодится функция operator.truth).

 list(keep_truthful([True, False, "", "foo"]))
[True, 'foo']

Функция abs_sum() принимает на вход итерируемый источник чисел. Вернуть же функция должна сумму абсолютных значений этих
чисел (используйте sum и abs).

 abs_sum([-3, 7])
10
 abs_sum([])
0
 abs_sum([42])
42

walk() должна для некоего словаря с глубокой вложенностью уметь доставать значение по указанному в виде iterable строк
пути. В решении можете использовать функцию operator.getitem.

Имейте в виду: мы считаем, что значения по указанному пути всегда доступны и сама структура словаря всегда правильная.
Это означает, что заранее обрабатывать ошибки не нужно. Так что реализуйте "оптимистичное решение".

 walk({'a': {7: {'b': 42}}}, ["a", 7, "b"])
42
 walk({'a': {7: {'b': 42}}}, ["a", 7])
{'b': 42}

"""
from operator import truth, getitem
from functools import reduce


def keep_truthful(arg):
    """Функция keep_truthful() должна принимать на вход итерируемый источник значений и возвращать итератор, отдающий только
те значения из источника, которые "истинны" (вам пригодится функция operator.truth)."""
    return list(filter(truth, arg))


print(keep_truthful([True, False, "", "foo"]))


def abs_sum(numbers):
    """Функция abs_sum() принимает на вход итерируемый источник чисел. Вернуть же функция должна сумму абсолютных
значений этих чисел (используйте sum и abs).  ---> [-3, 7] == 10"""

    return sum(map(abs, numbers))


print(abs_sum([-3, 7]))


def walk(dictionary, arg):
    """walk() должна для некоего словаря с глубокой вложенностью уметь доставать значение по указанному в виде iterable
строк пути. В решении можете использовать функцию operator.getitem.

Имейте в виду: мы считаем, что значения по указанному пути всегда доступны и сама структура словаря всегда правильная.
Это означает, что заранее обрабатывать ошибки не нужно. Так что реализуйте "оптимистичное решение".

 walk({'a': {7: {'b': 42}}}, ["a", 7, "b"])
42
 walk({'a': {7: {'b': 42}}}, ["a", 7])
{'b': 42}"""

    return reduce(getitem, arg, dictionary)


print(walk({'a': {7: {'b': 42}}}, ["a", 7, "b"]))
